SymbolTable ST; RegAll RA;unsigned int indentation = 0;inline void pyCodePrinter(ostream *strm, string msg) { for (int i = 0; i < indentation; i++) { *strm << "\t"; } *strm << msg;}template <typename T> inline bool isClass(Stmt *value) { return dynamic_cast<T *>(value) == NULL; }void AST::addToDot(ostream& out, int& nextnode) { int root = nextnode; ++nextnode; out << "\tn" << root << " [label=\"" << nodeLabel << "\"];" << endl; for (int i=0; i < children.size(); ++i) { int child = nextnode; children[i]->addToDot(out, nextnode); out << "\tn" << root << " -> n" << child << ";" << endl; }}void AST::writeDot(const char* fname) { ofstream fout(fname); int nodes = 1; fout << "digraph AST {" << endl; addToDot (fout, nodes); fout << "}" << endl; fout.close();}int Id::mkCode(Hand hand) {  int reg = RA.allocReg(); string *addr = ST.getMemoryAddress(this->getVal()); if (addr == NULL) { errout << "Variable " + this->getVal() + " doesn't exist yet\n"; error = true; return -1; } asmCodePrinter("LOAD $" + to_string(reg) + " " + *addr); return reg;}ArithOp::ArithOp(Exp* l, Oper o, Exp* r) {  op = o; left = l; right = r; nodeLabel = "Exp:ArithOp:"; switch(o) { case ADD: nodeLabel += '+'; break; case SUB: nodeLabel += '-'; break; case MUL: nodeLabel += '*'; break; case DIV: nodeLabel += '/'; break; default: nodeLabel += "ERROR"; } ASTchild(left); ASTchild(right);}Value ArithOp::eval() { int l = left->eval().num(); int r = right->eval().num(); switch(op) { case ADD: return l + r; case SUB: return l - r; case MUL: return l * r; case MOD: return l % r; case DIV:  if (r != 0) return l / r; else if (!error) { error = true; errout << "ERROR: Divide by zero" << endl; } return Value(); default: return Value();  }}string ArithOp::genCode() { switch (op) { case ADD: return left->genCode() + " + " + right->genCode(); case SUB: return left->genCode() + " - " + right->genCode(); case MUL: return left->genCode() + " * " + right->genCode(); case MOD: return left->genCode() + " % " + right->genCode(); case DIV: return left->genCode() + " / " + right->genCode(); default: error = true; resout << "Unknown Op\n"; } return "";}int ArithOp::mkCode(Hand hand) { string asmop; switch (op) { case ADD: asmop = "ADD"; break; case SUB: asmop = "SUB"; break; case MUL: asmop = "MUL"; break;  case MOD: asmop = "MOD"; break; case DIV: asmop = "DIV"; break;  default: error = true; resout << "Unknown Op\n"; } int lhsRegister, rhsRegister; lhsRegister = this->left->mkCode(LEFT); rhsRegister = this->right->mkCode(RIGHT); if (OPTIMIZATION_LEVEL >= LOW && this->left->suCount(LEFT) < this->right->suCount(RIGHT)) { rhsRegister = this->right->mkCode(RIGHT); lhsRegister = this->left->mkCode(LEFT); } asmCodePrinter(asmop + " $" + to_string(lhsRegister) + " $" + to_string(rhsRegister)); RA.freeReg(rhsRegister); return lhsRegister;}CompOp::CompOp(Exp* l, Oper o, Exp* r) { op = o; left = l; right = r; nodeLabel = "Exp:CompOp:"; switch(o) { case LT: nodeLabel += "<"; break; case GT: nodeLabel += ">"; break; case LE: nodeLabel += "<="; break; case GE: nodeLabel += ">="; break; case EQ: nodeLabel += "="; break; case NE: nodeLabel += "!="; break; default: nodeLabel += "ERROR"; break; } ASTchild(left); ASTchild(right);}Value CompOp::eval() { int leftValue = this->left->eval().num(); int rightValue = this->right->eval().num(); switch (this->op) { case LT: return Value(leftValue < rightValue); case LE: return Value(leftValue <= rightValue); case GT: return Value(leftValue > rightValue); case GE: return Value(leftValue >= rightValue); case EQ: return Value(leftValue == rightValue); case NE: return Value(leftValue != rightValue); default: error = true; errout << "Unknown Operator\n"; } return Value();}string CompOp::genCode() { switch (op) { case LT: return left->genCode() + " < " + right->genCode(); case LE: return left->genCode() + " <= " + right->genCode(); case GT: return left->genCode() + " > " + right->genCode(); case GE: return left->genCode() + " >= " + right->genCode(); case EQ: return left->genCode() + " == " + right->genCode(); case NE: return left->genCode() + " != " + right->genCode(); default: error = true; errout << "Unknown Op\n"; } return "";}int CompOp::mkCode(Hand hand) { int lhsRegister, rhsRegister; int blockNum = labelCounter(); if (this->left->suCount(LEFT) < this->right->suCount(RIGHT)) { rhsRegister = this->right->mkCode(RIGHT); lhsRegister = this->left->mkCode(LEFT); } else { lhsRegister = this->left->mkCode(LEFT); rhsRegister = this->right->mkCode(RIGHT); } if (lhsRegister == -1 || rhsRegister == -1) { return -1; } string strBlockNum = to_string(blockNum); string blockEnd = "compOpEnd_" + strBlockNum; string strLhR = "$" + to_string(lhsRegister); asmCodePrinter("SUB " + strLhR + " $" + to_string(rhsRegister)); switch (op) { case LT: asmCodePrinter("BNEG " + strLhR + " compOpPos_" + strBlockNum); asmCodePrinter("BRUN compOpNeg_" + strBlockNum); break; case LE: asmCodePrinter("BPOS " + strLhR + " compOpNeg_" + strBlockNum); asmCodePrinter("BRUN compOpPos_" + strBlockNum); break; case GT: asmCodePrinter("BPOS " + strLhR + " compOpPos_" + strBlockNum); asmCodePrinter("BRUN compOpNeg_" + strBlockNum); break; case GE: asmCodePrinter("BNEG " + strLhR + " compOpNeg_" + strBlockNum); asmCodePrinter("BRUN compOpPos_" + strBlockNum); break; case EQ: asmCodePrinter("BZO " + strLhR + " compOpPos_" + strBlockNum); asmCodePrinter("BRUN compOpNeg_" + strBlockNum); break; case NE: asmCodePrinter("BZO " + strLhR + " compOpNeg_" + strBlockNum); asmCodePrinter("BRUN compOpPos_" + strBlockNum); break; default: errout << "Unknown comparison operator\n"; error = true; break; } asmCodePrinter("compOpPos_" + strBlockNum + ": ", true); asmCodePrinter("LOAD " + strLhR + " 1"); asmCodePrinter("BRUN " + blockEnd); asmCodePrinter("compOpNeg_" + strBlockNum + ": ", true); asmCodePrinter("CLR " + strLhR); asmCodePrinter("BRUN " + blockEnd); asmCodePrinter(blockEnd + ": ", true); RA.freeReg(rhsRegister); return lhsRegister;}BoolOp::BoolOp(Exp* l, Oper o, Exp* r) { op = o; left = l; right = r; nodeLabel = "Exp:BoolOp:"; if (o == AND) nodeLabel += "and"; else nodeLabel += "or"; ASTchild(left); ASTchild(right);}Value BoolOp::eval() { bool leftValue = this->left->eval().tf(); bool rightValue = this->right->eval().tf(); switch (this->op) { case AND: return Value(leftValue && rightValue); case OR: return Value(leftValue || rightValue); default: error = true; errout << "Unknown Operator\n"; } return Value();}string BoolOp::genCode() { switch (op) { case OR: return left->genCode() + " or " + right->genCode(); case AND: return left->genCode() + " and " + right->genCode(); default: error = true; errout << "Unknown Op\n"; } return "";}void Block::mkCode() { body->mkCode(); getNext()->mkCode();}int BoolOp::mkCode(Hand hand) { int lhsRegister, rhsRegister; int blockNum = labelCounter(); if (OPTIMIZATION_LEVEL >= LOW) { if (left->suCount(LEFT) < right->suCount(RIGHT)) { rhsRegister = right->mkCode(RIGHT); lhsRegister = left->mkCode(LEFT); } else { lhsRegister = left->mkCode(LEFT); rhsRegister = right->mkCode(RIGHT); } } else { lhsRegister = left->mkCode(LEFT); rhsRegister = right->mkCode(RIGHT); } if (lhsRegister == -1 || rhsRegister == -1) { return -1; } string strBlockNum = to_string(blockNum); string blockEnd = "boolOpEnd_" + strBlockNum; string strLhR = "$" + to_string(lhsRegister); switch (op) { case OR: { asmCodePrinter("ORB " + strLhR + " $" + to_string(rhsRegister)); asmCodePrinter("BNZ " + strLhR + " boolOpPos_" + strBlockNum); break; } case AND: { asmCodePrinter("AND " + strLhR + " $" + to_string(rhsRegister)); asmCodePrinter("BNZ " + strLhR + " boolOpPos_" + strBlockNum); break; } default: { error = true; errout << "Operator isn't valid\n"; return -1; } } asmCodePrinter("BRUN " + blockEnd); asmCodePrinter("boolOpPos_" + strBlockNum + ":"); asmCodePrinter("LOAD " + strLhR + " 1"); asmCodePrinter("BRUN " + blockEnd); asmCodePrinter("boolOpNeg_" + strBlockNum + ":"); asmCodePrinter("CLR " + strLhR); asmCodePrinter("BRUN " + blockEnd); asmCodePrinter(blockEnd + ":"); RA.freeReg(rhsRegister); return lhsRegister;}int NegOp::mkCode(Hand hand) { int numReg = right->mkCode(LEFT); int reg = RA.allocReg(); asmCodePrinter("LOAD $" + to_string(reg) + " 0"); asmCodePrinter("SUB $" + to_string(reg) + " $" + to_string(numReg)); RA.freeReg(numReg); return reg;}int NotOp::mkCode(Hand hand) { int reg = this->right->mkCode(LEFT); int blockNum = labelCounter(); string strBlockNum = to_string(blockNum); string blockEnd = "notOpEnd_" + strBlockNum; asmCodePrinter("BZO $" + to_string(reg) + " boolOpPos_" + strBlockNum); asmCodePrinter("BRUN boolOpNeg_" + to_string(blockNum)); asmCodePrinter("notOpPos_" + strBlockNum + ":"); asmCodePrinter("LOAD $" + to_string(reg) + " 1"); asmCodePrinter("BRUN " + blockEnd); asmCodePrinter("boolOpNeg_" + strBlockNum + ":"); asmCodePrinter("CLR $" + to_string(reg)); asmCodePrinter("BRUN " + blockEnd); asmCodePrinter(blockEnd + ":"); return reg;}int Read::mkCode(Hand hand) { int reg = RA.allocReg(); asmCodePrinter("IIN $" + to_string(reg)); return reg;}Stmt* Stmt::append(Stmt* a, Stmt* b) { if (! a->hasNext()) return b; Stmt* last = a; while (last->getNext()->hasNext()) last = last->getNext(); last->setNext(b); return a;}Stmt::Stmt() { next = new NullStmt(); children.push_back(next);}void IfStmt::exec() { Value clauseResult = this->clause->eval(); if (clauseResult.getType() != BOOL_T) {  error = true; errout << "Type Error: if statement clause cannot be of type " << clauseResult.getType() << "\n"; } else { if (clauseResult.tf()) { this->ifblock->exec(); } else if (elseblock != NULL) { this->elseblock->exec(); } } getNext()->exec();}void IfStmt::genCode(ostream *strm) { pyCodePrinter(strm, "if " + this->clause->genCode() + ":\n"); indentation++;  ifblock->genCode(); indentation--; if (elseblock != NULL && elseblock->hasNext()) { pyCodePrinter(&resout, "else:\n"); indentation++; elseblock->genCode(); indentation--; } getNext()->genCode();}void IfStmt::mkCode() { bool hasElse = dynamic_cast<Block *>(elseblock); if (OPTIMIZATION_LEVEL >= HIGH && clause->isConstant()) {  if (clause->getConstantValue().tf() == 1) { ifblock->mkCode(); } else { if (hasElse) elseblock->mkCode(); } return; } uint64_t blockNum = labelCounter(); string strBlockNum = to_string(blockNum); int clauseValue = this->clause->mkCode(LEFT); if (clauseValue == -1) return; asmCodePrinter("BNZ $" + to_string(clauseValue) + " ifBlock_" + strBlockNum);  if (hasElse) { asmCodePrinter("BRUN ifBlockElse_" + strBlockNum); } else { asmCodePrinter("BRUN ifBlockEnd_" + strBlockNum); } asmCodePrinter("ifBlock_" + strBlockNum + ": ", true); this->ifblock->mkCode(); asmCodePrinter("BRUN ifBlockEnd_" + strBlockNum); if (hasElse) { asmCodePrinter("ifBlockElse_" + strBlockNum + ": ", true); this->elseblock->mkCode(); asmCodePrinter("BRUN ifBlockEnd_" + strBlockNum); } asmCodePrinter("ifBlockEnd_" + strBlockNum + ": ", true); getNext()->mkCode();}void WhileStmt::exec() { Value clauseResult = this->clause->eval(); if (clauseResult.getType() != BOOL_T) {  error = true; errout << "Type Error: while clause statement cannot be of type '" << clauseResult.getType() << "'\n"; } else { while (clauseResult.tf()) { body->exec(); clauseResult = this->clause->eval(); } } getNext()->exec();}void WhileStmt::genCode(ostream *strm) { pyCodePrinter(strm, "while " + clause->genCode() + ":\n"); indentation++; body->genCode(); indentation--; getNext()->genCode();}void WhileStmt::mkCode() { uint64_t blockNum = labelCounter(); string strBlockNum = to_string(blockNum); asmCodePrinter("whileBlock_" + strBlockNum + ":", true); if (OPTIMIZATION_LEVEL >= HIGH && clause->isConstant()) { if (clause->getConstantValue().tf()) { this->body->mkCode(); asmCodePrinter("BRUN whileBlock_" + strBlockNum); } } else { int clauseRegister = this->clause->mkCode(LEFT); asmCodePrinter("BZO $" + to_string(clauseRegister) + " whileBlockEnd_" + strBlockNum); this->body->mkCode(); asmCodePrinter("BRUN whileBlock_" + strBlockNum); asmCodePrinter("whileBlockEnd_" + strBlockNum + ":", true); RA.freeReg(clauseRegister); } getNext()->mkCode();}void NewStmt::exec() { std::string &variableName = lhs->getVal(); if (ST.lookup(variableName).getType() == NONE_T) { ST.bind(variableName, rhs->eval()); } else {  error = true; errout << "Cannot bind variable '" << variableName << "', it already exists\n"; } getNext()->exec();}void NewStmt::genCode(ostream *strm) { pyCodePrinter(strm, lhs->getVal() + " = " + rhs->genCode() + "\n"); getNext()->genCode();}void NewStmt::mkCode() { int valueRegister; string *mem = ST.getNewVariableAddress(lhs->getVal()); if (OPTIMIZATION_LEVEL >= HIGH && rhs->isConstant()) {  valueRegister = RA.allocReg(); asmCodePrinter("LOAD $" + to_string(valueRegister) + " " + to_string(rhs->getConstantValue().num())); } else { valueRegister = rhs->mkCode(RIGHT); } asmCodePrinter("STOR $" + to_string(valueRegister) + " " + *mem); RA.freeReg(valueRegister); getNext()->mkCode();}void Asn::exec() { std::string &variableName = lhs->getVal(); if (ST.lookup(variableName).getType() == NONE_T) { error = true; errout << "Cannot rebind variable '" << variableName << "', is doesn't exist\n"; } else { ST.rebind(variableName, rhs->eval()); }}void Asn::genCode(ostream *strm) { pyCodePrinter(strm, lhs->getVal() + " = " + rhs->genCode() + "\n"); getNext()->genCode();}void Asn::mkCode() { int valueRegister; string *mem = ST.getMemoryAddress(lhs->getVal()); if (mem == NULL) { errout << "Variable " + lhs->getVal() + " does not exist\n"; error = true; return; } if (OPTIMIZATION_LEVEL >= HIGH && rhs->isConstant()) { valueRegister = RA.allocReg(); asmCodePrinter("LOAD $" + to_string(valueRegister) + " " + to_string(rhs->getConstantValue().num())); } else { valueRegister = rhs->mkCode(RIGHT); } asmCodePrinter("STOR $" + to_string(valueRegister) + " " + *mem); RA.freeReg(valueRegister); getNext()->mkCode();}void Write::mkCode() { if (dynamic_cast<String *>(this->val) != NULL) { asmCodePrinter("STR " + *this->val->eval().str()); } else { int valueRegister; if (OPTIMIZATION_LEVEL >= HIGH && this->val->isConstant()) { valueRegister = RA.allocReg(); asmCodePrinter("LOAD $" + to_string(valueRegister) + " " + to_string(this->val->getConstantValue().num())); } else { valueRegister = this->val->mkCode(LEFT); } asmCodePrinter("OUT $" + to_string(valueRegister)); RA.freeReg(valueRegister); } if (this->ln) { asmCodePrinter("NL"); } getNext()->mkCode();}string Lambda::genCode() { stringstream strm; strm << "lambda " << var->getVal() << ": "; body->genCode(&strm); return strm.str();}Value Funcall::eval() { Value a = arg->eval(); Value lambdaValue = funexp->eval(); if (lambdaValue.getType() != FUN_T) { error = true; errout << "Function is not a function\n"; } Lambda *lambda = lambdaValue.func();  ST.bind("ret", Value(1)); ST.bind(lambda->getVar(), a); lambda->getBody()->exec(); return ST.lookup("ret");}string Funcall::genCode() { return funexp->genCode() + "(" + arg->genCode() + ")";}
